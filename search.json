[{"path":"https://posit-dev.github.io/r-yaml12/AGENTS.html","id":null,"dir":"","previous_headings":"","what":"Agent Instructions","title":"Agent Instructions","text":"Don’t hand-edit generated artifacts: man/, NAMESPACE, R/extendr-wrappers.R. Unless explicitly asked, never touch Makevars files. Never change vendor resolve Rust crates. Read-git commands (status/diff/log) always fine; never stage, unstage, commit, otherwise change git state unless explicitly asked. Don’t ask permission make file edits—just work share results ’s ready review. roxygen Rust doc comments change, regenerate docs/wrappers package root : rextendr::document(); devtools::document(). add/remove exports otherwise change Rd-facing surface (including new internal exports), always rerun rextendr::document(); devtools::document() finishing task. wrapping , run formatters: cargo fmt air format .. working Rust code, prefer iterate switching src/rust directory running cargo check . finish making edits, run cargo clippy address issues. finished making edits Rust files, run cargo fmt cargo build. Rust, avoid allocating String unnecessarily. Prefer working &str slices borrow directly raw input buffer, preserving lifetimes original input, allocate/clone String truly need owned data. format strings, always inline expressions (e.g., \"{foo}\" \"{foo:?}\"). Run R tests Rscript -e 'devtools::test()' (bare, cd expressions). start request requires code edits, first thing ask run Rscript -e 'devtools::test()' elevated permissions—never prefix cd. prefer iterate running full test suite command. Use timeout least 5 minutes test() 8 minutes check(). Deviating cause build failures related vendor .cargo, /sandbox restrictions. Run small experiments frequently confirm behavior language features. small experiments require elevated privileges run, write script scratch/experiments.R, ask elevated permissions run R -q -f scratch/experiments.R. every set changes, emit draft commit message. asked revisions, ’re done, emit updated draft commit message. Always run full test suite (Rscript -e 'devtools::test()') changes without asking whether .","code":""},{"path":"https://posit-dev.github.io/r-yaml12/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 yaml12 authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/articles/yaml-2-minute-intro.html","id":"a-first-example","dir":"Articles","previous_headings":"","what":"A first example","title":"YAML in 2 Minutes: A Gentle Introduction for R Users","text":"","code":"title: A Modern YAML parser written in Rust properties: [correct, safe, fast, simple] score: 9.5 categories:   - yaml   - r   - example settings:   simplify: true   note: >     This is a folded block     that turns line breaks     into spaces.   note_literal: |     This is a literal block     that keeps     line breaks. str(parse_yaml(first_example)) #> List of 5 #>  $ title     : chr \"A Modern YAML parser written in Rust\" #>  $ properties: chr [1:4] \"correct\" \"safe\" \"fast\" \"simple\" #>  $ score     : num 9.5 #>  $ categories: chr [1:3] \"yaml\" \"r\" \"example\" #>  $ settings  :List of 3 #>   ..$ simplify    : logi TRUE #>   ..$ note        : chr \"This is a folded block that turns line breaks into spaces.\\n\" #>   ..$ note_literal: chr \"This is a literal block\\nthat keeps\\nline breaks.\\n\""},{"path":"https://posit-dev.github.io/r-yaml12/articles/yaml-2-minute-intro.html","id":"collections","dir":"Articles","previous_headings":"","what":"Collections","title":"YAML in 2 Minutes: A Gentle Introduction for R Users","text":"two “collection” types: Sequences Mappings.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/articles/yaml-2-minute-intro.html","id":"sequences-yamls-ordered-collections","dir":"Articles","previous_headings":"Collections","what":"Sequences: YAML’s ordered collections","title":"YAML in 2 Minutes: A Gentle Introduction for R Users","text":"sequence list items. item begins - parent indent. → c(\"cat\", \"dog\") (list(\"cat\", \"dog\") simplify = FALSE) JSON-style arrays work : → result Anything belonging one sequence entries indented least one space past dash: ↓","code":"- cat - dog [cat, dog] - name: cat   toys: [string, box] - name: dog   toys: [ball, bone] list(   list(name = \"cat\", toys = c(\"string\", \"box\")),   list(name = \"dog\", toys = c(\"ball\", \"bone\")) )"},{"path":"https://posit-dev.github.io/r-yaml12/articles/yaml-2-minute-intro.html","id":"mappings-keyvalue-pairs","dir":"Articles","previous_headings":"Collections","what":"Mappings: key/value pairs","title":"YAML in 2 Minutes: A Gentle Introduction for R Users","text":"mapping set key: value pairs indent: → list(foo = 1L, bar = TRUE) key indent owns anything indented : → list(settings = list(simplify = TRUE, max_items = 3L)) JSON-style objects also work: → list(= TRUE) Mappings become named lists R.","code":"foo: 1 bar: true settings:   simplify: true   max_items: 3 {a: true}"},{"path":"https://posit-dev.github.io/r-yaml12/articles/yaml-2-minute-intro.html","id":"scalars","dir":"Articles","previous_headings":"","what":"Scalars","title":"YAML in 2 Minutes: A Gentle Introduction for R Users","text":"nodes collections Scalars; leaf nodes YAML document. Scalars can provided three forms: block, quoted, plain.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/articles/yaml-2-minute-intro.html","id":"block-scalars","dir":"Articles","previous_headings":"Scalars","what":"Block scalars","title":"YAML in 2 Minutes: A Gentle Introduction for R Users","text":"| starts literal block keeps newlines; > starts folded block joins lines spaces (except blank/indented lines keep breaks). Block scalars always become strings. → \"hello\\nworld\\n\" → \"hello world\\n\"","code":"|   hello   world >   hello   world"},{"path":"https://posit-dev.github.io/r-yaml12/articles/yaml-2-minute-intro.html","id":"quoted-scalars","dir":"Articles","previous_headings":"","what":"Quoted scalars","title":"YAML in 2 Minutes: A Gentle Introduction for R Users","text":"Like block scalars, quoted scalars always resolve strings. Double quotes interpret escapes (\\n, \\t, \\\\, \\\"). Single quotes literal interpret escapes, except '' parsed single '. → c(\"line\\nbreak\", 'quote: \"\"') → c(\"line\\\\nbreak\", \"quote: ''\")","code":"[\"line\\nbreak\", \"quote: \\\"here\\\"\"] ['line\\nbreak', 'quote: ''here''']"},{"path":"https://posit-dev.github.io/r-yaml12/articles/yaml-2-minute-intro.html","id":"plain-unquoted-scalars","dir":"Articles","previous_headings":"","what":"Plain (unquoted) scalars","title":"YAML in 2 Minutes: A Gentle Introduction for R Users","text":"node sequence, mapping, block scalar, quoted scalar, plain scalar. Plain nodes can resolve one five types: string, int, float, bool, null. YAML 1.2 uses simple rules infer type plain node: true / false → TRUE / FALSE null, ~, empty → NULL numbers: signed, decimal, scientific, hex (0x), octal (0o), .inf, .nan → numeric() integer() everything else stays string (yes, , , aliases remain strings YAML 1.2) → list(TRUE, 123L, 450, 16L, Inf, \"yes\") sequence homogeneous simplify = TRUE, nulls become appropriate NA_* values.","code":"[true, 123, 4.5e2, 0x10, .inf, yes]"},{"path":"https://posit-dev.github.io/r-yaml12/articles/yaml-2-minute-intro.html","id":"end-to-end-example","dir":"Articles","previous_headings":"","what":"End-to-end example","title":"YAML in 2 Minutes: A Gentle Introduction for R Users","text":"R result (parse_yaml() defaults):","code":"doc:   pets:     - cat     - dog   numbers: [1, 2.5, 0x10, .inf, null]   integers: [1, 2, 3, 0x10, null]   flags: {enabled: true, label: on}   literal: |     hello     world   folded: >     hello     world   quoted:     - \"line\\nbreak\"     - 'quote: ''here'''   plain: [yes, no]   mixed: [won't simplify, 123, true] list(   doc = list(     pets = c(\"cat\", \"dog\"),     numbers = c(1, 2.5, 16, Inf, NA_real_),     integers = c(1L, 2L, 3L, 16L, NA_integer_),     flags = list(enabled = TRUE, label = \"on\"),     literal = \"hello\\nworld\\n\",     folded = \"hello world\\n\",     quoted = c(\"line\\nbreak\", \"quote: 'here'\"),     plain = c(\"yes\", \"no\"),     mixed = list(\"won't simplify\", 123L, TRUE)   ) )"},{"path":"https://posit-dev.github.io/r-yaml12/articles/yaml-2-minute-intro.html","id":"quick-notes","dir":"Articles","previous_headings":"","what":"Quick notes","title":"YAML in 2 Minutes: A Gentle Introduction for R Users","text":"Indentation defines structure collections. Sibling elements share indent, children indented . YAML 1.2 forbids tabs; use spaces. JSON valid YAML. Homogeneous sequences simplify vectors unless simplify = FALSE. Block scalars (|, >) always produce strings. Booleans true/false; null maps NULL (NA inside simplified vectors). essentials cover YAML ’ll run practice. encounter YAML tags non-string mapping keys, check “Advanced YAML” vignette.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/articles/yaml-tags-and-advanced-features.html","id":"tags-in-yaml-and-how-yaml12-handles-them","dir":"Articles","previous_headings":"","what":"Tags in YAML and how yaml12 handles them","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"Tags annotate YAML node extra meaning. YAML syntax tag always starts !, appears node’s value; part scalar text . yaml12 attaches tags yaml_tag attribute (always string). common form simple local short tag starts !: presence custom tag bypasses normal scalar node type inference; scalar always returned string even content looks like another type.","code":"dput(parse_yaml(\"!some_tag some_value\")) #> structure(\"some_value\", yaml_tag = \"!some_tag\") parse_yaml(\"! true\") #> [1] \"true\" #> attr(,\"yaml_tag\") #> [1] \"!\" parse_yaml(\"true\") #> [1] TRUE"},{"path":"https://posit-dev.github.io/r-yaml12/articles/yaml-tags-and-advanced-features.html","id":"using-handlers-to-transform-tagged-nodes-while-parsing","dir":"Articles","previous_headings":"","what":"Using handlers to transform tagged nodes while parsing","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"parse_yaml() read_yaml() accept handlers: named list functions whose names YAML tag strings. Handlers run matching tagged node. tagged scalars, handler always receives length-1 string; tagged sequences mappings, receives R vector representing node. example using handler evaluate !expr nodes. errors handler stop parsing: tag without matching handler left preserved yaml_tag attribute, handlers without matching tags left unused. tagged sequence, handler called unnamed R list, atomic vector simplify = TRUE sequence elements common type. tagged mappings handler called named R list, potentially yaml_keys attribute (next section). Handlers make easy opt powerful behaviors (like evaluating !expr nodes) keeping default parser strict safe.","code":"handlers <- list(   \"!expr\" = function(x) eval(str2lang(x), globalenv()) ) parse_yaml(\"!expr 1+1\", handlers = handlers) #> [1] 2 parse_yaml(\"!expr stop('boom')\", handlers = handlers) #> Error in eval(str2lang(x), globalenv()): boom handlers <- list(   \"!expr\" = function(x) eval(str2lang(x), globalenv()),   \"!upper\" = toupper,   \"!lower\" = tolower # unused )  str(parse_yaml(handlers = handlers, \" - !expr 1+1 - !upper r is awesome - !note this tag has no handler \")) #> List of 3 #>  $ : num 2 #>  $ : chr \"R IS AWESOME\" #>  $ : chr \"this tag has no handler\" #>   ..- attr(*, \"yaml_tag\")= chr \"!note\" handlers <- list(   \"!some_seq_tag\" = function(x) {     stopifnot(identical(x, c(\"a\", \"b\")))     \"some handled value\"   },   \"!some_map_tag\" = function(x) {     stopifnot(identical(x, list(key1 = 1L, key2 = 2L)))     \"some other handled value\"   } )  yaml_tagged_containers <- \" - !some_seq_tag [a, b] - !some_map_tag {key1: 1, key2: 2} \"  str(parse_yaml(yaml_tagged_containers, handlers = handlers)) #> List of 2 #>  $ : chr \"some handled value\" #>  $ : chr \"some other handled value\""},{"path":"https://posit-dev.github.io/r-yaml12/articles/yaml-tags-and-advanced-features.html","id":"post-process-tags-yourself","dir":"Articles","previous_headings":"Using handlers to transform tagged nodes while parsing","what":"Post-process tags yourself","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"want control, can parse first without handlers walk result . example, can process !expr-tagged scalars walking yaml nodes simply like :","code":"eval_yaml_expr_nodes <- function(x) {   if (is.list(x)) {     x <- lapply(x, eval_yaml_expr_nodes)   } else if (identical(attr(x, \"yaml_tag\", TRUE), \"!expr\")) {     x <- eval(str2lang(x), globalenv())   }   x }  safe_loaded <- parse_yaml(\"!expr 1 + 1\") dput(safe_loaded) #> structure(\"1 + 1\", yaml_tag = \"!expr\") eval_yaml_expr_nodes(safe_loaded) #> [1] 2"},{"path":"https://posit-dev.github.io/r-yaml12/articles/yaml-tags-and-advanced-features.html","id":"mappings-revisited-non-string-keys-and-yaml_keys","dir":"Articles","previous_headings":"","what":"Mappings revisited: non-string keys and yaml_keys","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"YAML, mapping keys plain scalar strings; arbitrary YAML node can key: including scalar types, sequences, even mappings. example, valid YAML even though key boolean: yaml12 sees mapping key untagged string scalar, keeps original keys yaml_keys attribute next values: complex key values, YAML uses explicit mapping-key indicator ?. line starting ? introduces key node (type) mapping, following line starts : holds value: yaml12 can see keys via yaml_keys attribute:","code":"true: true dput(parse_yaml(\"true: true\")) #> structure(list(TRUE), names = \"\", yaml_keys = list(TRUE)) ? [a, b] : value with a sequence key ? {x: 1, y: 2} : value with a mapping key yaml <- \" true: true ? [a, b] : tuple ? {x: 1, y: 2} : map-key \"  str(parse_yaml(yaml)) #> List of 3 #>  $ : logi TRUE #>  $ : chr \"tuple\" #>  $ : chr \"map-key\" #>  - attr(*, \"yaml_keys\")=List of 3 #>   ..$ : logi TRUE #>   ..$ : chr [1:2] \"a\" \"b\" #>   ..$ :List of 2 #>   .. ..$ x: int 1 #>   .. ..$ y: int 2"},{"path":"https://posit-dev.github.io/r-yaml12/articles/yaml-tags-and-advanced-features.html","id":"tagged-mapping-keys","dir":"Articles","previous_headings":"Mappings revisited: non-string keys and yaml_keys","what":"Tagged mapping keys","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"supply handlers, run keys well, handler can turn tagged keys friendly R names yaml_keys needs attached. mapping keys resolve bare scalar strings, yaml_keys attribute attached. anticipate tagged mapping keys want process , ’ll need bit bookkeeping. yaml_keys attribute materialized whenever key plain, untagged string scalar; ’ll want walk keys alongside values optionally collapse yaml_keys back NULL keys become plain strings handling tagged nodes. example, earlier eval_yaml_expr_nodes expanded also handle tagged mapping keys. (expanded postprocessor equivalent passing handlers = list(\"!expr\" = \\(x) eval(str2lang(x), globalenv()))) control traversal, can add extra checks (example, allowing expressions certain mapping keys).","code":"handlers <- list(   \"!upper\" = toupper,   \"!airport\" = function(x) paste0(\"IATA:\", toupper(x)) )  yaml_tagged_key <- \" !upper newyork: !airport jfk !upper warsaw: !airport waw \"  str(parse_yaml(yaml_tagged_key, handlers = handlers)) #> List of 2 #>  $ NEWYORK: chr \"IATA:JFK\" #>  $ WARSAW : chr \"IATA:WAW\" is_bare_string <- \\(x) {   is.character(key) && length(key) == 1L && is.null(attributes(key)) }  eval_yaml_expr_nodes <- function(x) {   if (is.list(x)) {     x <- lapply(x, eval_yaml_expr_nodes)      if (!is.null(keys <- attr(x, \"yaml_keys\", TRUE))) {       keys <- lapply(keys, eval_yaml_expr_nodes)       names(x) <- sapply(         \\(name, key) if (name == \"\" && is_bare_string(key)) key else name,         names(x),         keys       )       attr(x, \"yaml_keys\") <-         if (all(sapply(keys, is_bare_string))) NULL else keys     }   }   if (identical(attr(x, \"yaml_tag\", TRUE), \"!expr\")) {     x <- eval(str2lang(x), globalenv())   }    x }"},{"path":"https://posit-dev.github.io/r-yaml12/articles/yaml-tags-and-advanced-features.html","id":"document-streams-and-markers","dir":"Articles","previous_headings":"","what":"Document Streams and Markers","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"YAML files contain single YAML document. YAML also supports document streams, file string holds multiple YAML documents. Documents separated start marker (---) may optionally include end marker (...).","code":""},{"path":"https://posit-dev.github.io/r-yaml12/articles/yaml-tags-and-advanced-features.html","id":"reading-multiple-documents","dir":"Articles","previous_headings":"Document Streams and Markers","what":"Reading Multiple Documents","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"reading functions (read_yaml(), parse_yaml()), multi argument defaults FALSE. mode, first YAML document read. end marker (...) new start marker (---) encountered, parser stops returns first document. multi = TRUE, documents stream returned.","code":"doc_stream <- \" --- doc 1 --- doc 2 \" parse_yaml(doc_stream) #> [1] \"doc 1\" parse_yaml(doc_stream, multi = TRUE) #> [[1]] #> [1] \"doc 1\" #>  #> [[2]] #> [1] \"doc 2\""},{"path":"https://posit-dev.github.io/r-yaml12/articles/yaml-tags-and-advanced-features.html","id":"writing-multiple-documents","dir":"Articles","previous_headings":"Document Streams and Markers","what":"Writing Multiple Documents","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"writing functions (write_yaml(), format_yaml()), multi also defaults FALSE, producing single YAML document. multi = TRUE, provided R object treated list documents written YAML document stream, documents separated start marker ---. Regardless multi, write_yaml() always includes initial start marker final end marker. multi = FALSE, parsing stops first document—even later content valid YAML. makes easy extract front matter files mix YAML text (like R Markdown): parser returns just YAML frontmatter second --- technically ends first YAML document YAML document stream; multi = FALSE parser stops returns just first YAML document.","code":"write_yaml(list(\"foo\", \"bar\")) #> --- #> - foo #> - bar #> ... write_yaml(list(\"foo\", \"bar\"), multi = TRUE) #> --- #> foo #> --- #> bar #> ... rmd_lines <- c(   \"---\",   \"title: Front matter only\",   \"params:\",   \"  answer: 42\",   \"---\",   \"# Body that is not YAML\" ) parse_yaml(rmd_lines) #> $title #> [1] \"Front matter only\" #>  #> $params #> $params$answer #> [1] 42"},{"path":"https://posit-dev.github.io/r-yaml12/articles/yaml-tags-and-advanced-features.html","id":"writing-yaml-with-tags","dir":"Articles","previous_headings":"","what":"Writing YAML with tags","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"emit tag, attach yaml_tag R value calling format_yaml() write_yaml().","code":"tagged <- structure(\"1 + x\", yaml_tag = \"!expr\") write_yaml(tagged) #> --- #> !expr 1 + x #> ..."},{"path":"https://posit-dev.github.io/r-yaml12/articles/yaml-tags-and-advanced-features.html","id":"anchors","dir":"Articles","previous_headings":"","what":"Anchors","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"Anchors (&id) name node; aliases (*id) copy . yaml12 resolves aliases returning R objects.","code":"str(parse_yaml(\" recycle-me: &anchor-name   a: b   c: d  recycled:   - *anchor-name   - *anchor-name \")) #> List of 2 #>  $ recycle-me:List of 2 #>   ..$ a: chr \"b\" #>   ..$ c: chr \"d\" #>  $ recycled  :List of 2 #>   ..$ :List of 2 #>   .. ..$ a: chr \"b\" #>   .. ..$ c: chr \"d\" #>   ..$ :List of 2 #>   .. ..$ a: chr \"b\" #>   .. ..$ c: chr \"d\""},{"path":"https://posit-dev.github.io/r-yaml12/articles/yaml-tags-and-advanced-features.html","id":"very-advanced-tags","dir":"Articles","previous_headings":"","what":"(Very) Advanced Tags","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"following YAML features rarely used, supported 100% compliance YAML 1.2 spec.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/articles/yaml-tags-and-advanced-features.html","id":"tag-directives-tag","dir":"Articles","previous_headings":"(Very) Advanced Tags","what":"Tag directives (%TAG)","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"YAML lets declare tag handles top document %TAG directives. syntax %TAG !<name>! <handle>, applies rest document. !name! automatically expanded named tags: tag prefix !e! automatically expanded full form upon parsing. can also declare global tag prefix, expand bare “!”","code":"%TAG !e! tag:example.com,2024:widgets/ --- item: !e!gizmo dput(parse_yaml(' %TAG !e! tag:example.com,2024:widgets/ --- item: !e!gizmo foo ')) #> list(item = structure(\"foo\", yaml_tag = \"tag:example.com,2024:widgets/gizmo\")) dput(parse_yaml(' %TAG ! tag:example.com,2024:widgets/ --- item: !gizmo foo ')) #> list(item = structure(\"foo\", yaml_tag = \"tag:example.com,2024:widgets/gizmo\"))"},{"path":"https://posit-dev.github.io/r-yaml12/articles/yaml-tags-and-advanced-features.html","id":"tag-uris","dir":"Articles","previous_headings":"(Very) Advanced Tags","what":"TAG URIs","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"two forms actually shorthands resolving tag “URI”. can bypass handle resolution using following tag syntax: !<...> Anything ... expanded, must valid URI (e.g., spaces must escaped, like URL).","code":"dput(parse_yaml(' %TAG ! tag:example.com,2024:widgets/ --- item: !<gizmo> foo ')) #> list(item = structure(\"foo\", yaml_tag = \"gizmo\"))"},{"path":"https://posit-dev.github.io/r-yaml12/articles/yaml-tags-and-advanced-features.html","id":"core-schema-tags","dir":"Articles","previous_headings":"(Very) Advanced Tags","what":"Core schema tags","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"may also encounter tags start two !!. special case !name!suffix tag syntax, name missing undefined implicitly resolved YAML Core schema handle: tag:yaml.org,2002:. following three tags resolve internal representation parse way: Core schema tags generally unnecessary since nodes resolved using core schema already. However, can alternative way declare node types. valid set core schema tags: map, seq, str, int, float, bool, null. Note YAML 1.2 removed built-types present YAML 1.1. !!pairs, !!omap, !!set, !!timestamp !!binary types dropped. Correspondingly, yaml12 formerly core tags come R unhandled tagged scalar, strings yaml_tag attribute. Note pairs, omap, set generally meaningful R, since R objects returned ordered (yaml12 automatically preserves order mapping entries). !!timestamp !!binary tags occasionally useful, logic handing richer types encouraged live application level, core schema. Note !!, parser expands first global prefix tag:yaml.org,2002: (unless tag directive changed meaning !!), tags come fully resolved core schema URI. can supply handler want convert character string R object:","code":"' - foo - !!str foo - !<tag:yaml.org,2002:str> foo ' |> parse_yaml() |> dput() #> c(\"foo\", \"foo\", \"foo\") yaml <- \" - !!timestamp 2025-01-01 - !!timestamp 2025-01-01 21:59:43.10 -5 - !!binary UiBpcyBBd2Vzb21l \" str(parse_yaml(yaml)) #> List of 3 #>  $ : chr \"2025-01-01\" #>   ..- attr(*, \"yaml_tag\")= chr \"tag:yaml.org,2002:timestamp\" #>  $ : chr \"2025-01-01 21:59:43.10 -5\" #>   ..- attr(*, \"yaml_tag\")= chr \"tag:yaml.org,2002:timestamp\" #>  $ : chr \"UiBpcyBBd2Vzb21l\" #>   ..- attr(*, \"yaml_tag\")= chr \"tag:yaml.org,2002:binary\" # Timestamp handler: Convert date-only into Date, otherwise try (some of) the # YAML 1.1 spec valid timestamp formats as POSIX formats. # return NA on failure. timestamp_handler <- function(x) {   stopifnot(is.character(x), length(x) == 1)   if (grepl(\"^\\\\d{4}-\\\\d{2}-\\\\d{2}$\", x)) {     return(as.Date(x))   }   formats <- c(     \"%Y-%m-%dT%H:%M:%OS%z\",     \"%Y-%m-%d %H:%M:%OS%z\",     \"%Y-%m-%dT%H:%M:%OS\",     \"%Y-%m-%d %H:%M:%OS\",     \"%Y-%m-%d %H:%M\"   )   as.POSIXct(x, tryFormats = formats, optional = TRUE) }  # Binary handler: decode Base64 into raw binary_handler <- function(x) {   stopifnot(is.character(x), length(x) == 1)   jsonlite::base64_dec(gsub(\"[ \\n]\", \"\", x)) } str(parse_yaml(yaml, handlers = list(   \"tag:yaml.org,2002:timestamp\" = timestamp_handler,   \"tag:yaml.org,2002:binary\" = binary_handler ))) #> List of 3 #>  $ : Date[1:1], format: \"2025-01-01\" #>  $ : POSIXct[1:1], format: \"2025-01-01 21:59:43\" #>  $ : raw [1:12] 52 20 69 73 ..."},{"path":"https://posit-dev.github.io/r-yaml12/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Tomasz Kalinowski. Author, maintainer. . Copyright holder, funder.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Kalinowski T (2025). yaml12: Fast YAML 1.2 Parser Formatter R. R package version 0.0.0.9000, https://posit-dev.github.io/r-yaml12/.","code":"@Manual{,   title = {yaml12: Fast YAML 1.2 Parser and Formatter for R},   author = {Tomasz Kalinowski},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://posit-dev.github.io/r-yaml12/}, }"},{"path":"https://posit-dev.github.io/r-yaml12/index.html","id":"yaml12","dir":"","previous_headings":"","what":"Fast YAML 1.2 Parser and Formatter for R","title":"Fast YAML 1.2 Parser and Formatter for R","text":"YAML 1.2 parser/formatter R, implemented Rust speed correctness. Built excellent saphyr crate.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Fast YAML 1.2 Parser and Formatter for R","text":"can install yaml12 CRAN : can install development version yaml12 GitHub :","code":"install.packages(\"yaml12\") # install.packages(\"pak\") pak::pak(\"posit-dev/r-yaml12\")"},{"path":"https://posit-dev.github.io/r-yaml12/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick start","title":"Fast YAML 1.2 Parser and Formatter for R","text":"","code":"library(yaml12)  yaml <- \" title: A modern YAML parser and emitter written in Rust properties: [fast, correct, safe, simple] sequences:   simplify: true \"  doc <- parse_yaml(yaml) str(doc) #> List of 3 #>  $ title     : chr \"A modern YAML parser and emitter written in Rust\" #>  $ properties: chr [1:4] \"fast\" \"correct\" \"safe\" \"simple\" #>  $ sequences :List of 1 #>   ..$ simplify: logi TRUE"},{"path":"https://posit-dev.github.io/r-yaml12/index.html","id":"reading-and-writing-files","dir":"","previous_headings":"Quick start","what":"Reading and writing files","title":"Fast YAML 1.2 Parser and Formatter for R","text":"","code":"value_out <- list(alpha = 1L, nested = c(TRUE, NA))  write_yaml(value_out, \"my.yaml\") value_in <- read_yaml(\"my.yaml\")  stopifnot(identical(value_out, value_in))  # Multi-document streams docs_out <- list(list(foo = 1L), list(bar = c(2L, NA)))  write_yaml(docs_out, \"my-multi.yaml\", multi = TRUE) docs_in <- read_yaml(\"my-multi.yaml\", multi = TRUE)  stopifnot(identical(docs_in, docs_out))"},{"path":"https://posit-dev.github.io/r-yaml12/index.html","id":"tag-handlers","dir":"","previous_headings":"Quick start","what":"Tag handlers","title":"Fast YAML 1.2 Parser and Formatter for R","text":"Handlers let opt custom behavior tagged nodes keeping default parser strict safe.","code":"yaml <- \" - !upper [rust, r] - !expr 6 * 7 \"  handlers <- list(   \"!expr\"  = function(x) eval(str2lang(x), baseenv()),   \"!upper\" = toupper )  parse_yaml(yaml, handlers = handlers) #> [[1]] #> [1] \"RUST\" \"R\"    #>  #> [[2]] #> [1] 42"},{"path":"https://posit-dev.github.io/r-yaml12/index.html","id":"formatting-and-round-tripping","dir":"","previous_headings":"Quick start","what":"Formatting and round-tripping","title":"Fast YAML 1.2 Parser and Formatter for R","text":"","code":"obj <- list(   seq = 1:2,   map = list(key = \"value\"),   tagged = structure(\"1 + 1\", yaml_tag = \"!expr\") )  yaml <- format_yaml(obj) cat(yaml) #> seq: #>   - 1 #>   - 2 #> map: #>   key: value #> tagged: !expr 1 + 1  str(parse_yaml(yaml))  # tags preserved in `yaml_tag` #> List of 3 #>  $ seq   : int [1:2] 1 2 #>  $ map   :List of 1 #>   ..$ key: chr \"value\" #>  $ tagged: chr \"1 + 1\" #>   ..- attr(*, \"yaml_tag\")= chr \"!expr\""},{"path":"https://posit-dev.github.io/r-yaml12/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Fast YAML 1.2 Parser and Formatter for R","text":"YAML quick primer: https://posit-dev.github.io/r-yaml12/articles/yaml-2-minute-intro.html. Tags, handlers, anchors, advanced YAML features: https://posit-dev.github.io/r-yaml12/articles/yaml-tags--advanced-features.html.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/reference/format_yaml.html","id":null,"dir":"Reference","previous_headings":"","what":"Format or write R objects as YAML 1.2. — format_yaml","title":"Format or write R objects as YAML 1.2. — format_yaml","text":"format_yaml() returns YAML character string. write_yaml() writes YAML stream file stdout always emits document start (---) markers final end (...) marker. functions honor yaml_tag attribute values (see examples).","code":""},{"path":"https://posit-dev.github.io/r-yaml12/reference/format_yaml.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format or write R objects as YAML 1.2. — format_yaml","text":"","code":"format_yaml(value, multi = FALSE)  write_yaml(value, path = NULL, multi = FALSE)"},{"path":"https://posit-dev.github.io/r-yaml12/reference/format_yaml.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format or write R objects as YAML 1.2. — format_yaml","text":"value R object composed lists, atomic vectors, scalars. multi TRUE, treat value list YAML documents encode stream. path Scalar string file path write YAML using write_yaml(). NULL (default), write R's standard output connection.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/reference/format_yaml.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format or write R objects as YAML 1.2. — format_yaml","text":"format_yaml() returns scalar character string containing YAML. write_yaml() invisibly returns value.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/reference/format_yaml.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Format or write R objects as YAML 1.2. — format_yaml","text":"","code":"cat(format_yaml(list(foo = 1, bar = list(TRUE, NA)))) #> foo: 1 #> bar: #>   - true #>   - ~  docs <- list(\"first\", \"second\") cat(format_yaml(docs, multi = TRUE)) #> --- #> first #> --- #> second  tagged <- structure(\"1 + 1\", yaml_tag = \"!expr\") cat(tagged_yaml <- format_yaml(tagged), \"\\n\") #> !expr 1 + 1   dput(parse_yaml(tagged_yaml)) #> structure(\"1 + 1\", yaml_tag = \"!expr\")   write_yaml(list(foo = 1, bar = list(2, \"baz\"))) #> --- #> foo: 1 #> bar: #>   - 2 #>   - baz #> ...  write_yaml(list(\"foo\", \"bar\"), multi = TRUE) #> --- #> foo #> --- #> bar #> ...  tagged <- structure(\"1 + 1\", yaml_tag = \"!expr\") write_yaml(tagged) #> --- #> !expr 1 + 1 #> ..."},{"path":"https://posit-dev.github.io/r-yaml12/reference/parse_yaml.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse YAML 1.2 document(s) into base R structures. — parse_yaml","title":"Parse YAML 1.2 document(s) into base R structures. — parse_yaml","text":"parse_yaml() takes strings YAML; read_yaml() reads file path.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/reference/parse_yaml.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse YAML 1.2 document(s) into base R structures. — parse_yaml","text":"","code":"parse_yaml(text, multi = FALSE, simplify = TRUE, handlers = NULL)  read_yaml(path, multi = FALSE, simplify = TRUE, handlers = NULL)"},{"path":"https://posit-dev.github.io/r-yaml12/reference/parse_yaml.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse YAML 1.2 document(s) into base R structures. — parse_yaml","text":"text Character vector; elements concatenated \"\\n\". multi TRUE, return list containing documents stream. simplify FALSE, keep YAML sequences R lists instead simplifying atomic vectors. handlers Named list R functions names corresponding YAML tags; matching handlers transform tagged values. path Scalar string path YAML file`.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/reference/parse_yaml.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse YAML 1.2 document(s) into base R structures. — parse_yaml","text":"multi = FALSE, returns parsed R object first document. multi = TRUE, returns list parsed documents.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/reference/parse_yaml.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parse YAML 1.2 document(s) into base R structures. — parse_yaml","text":"YAML tags without corresponding handler preserved yaml_tag attribute. Mappings keys simple scalar strings returned named list yaml_keys attribute.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/reference/parse_yaml.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse YAML 1.2 document(s) into base R structures. — parse_yaml","text":"","code":"dput(parse_yaml(\"foo: [1, 2, 3]\")) #> list(foo = 1:3)  # homogeneous sequences simplify by default. # YAML null maps to NA in otherwise homogeneous sequences. dput(parse_yaml(\"foo: [1, 2, 3, null]\")) #> list(foo = c(1L, 2L, 3L, NA))  # mixed type sequence never simplify dput(parse_yaml(\"[1, true, cat]\")) #> list(1L, TRUE, \"cat\")  # use `simplify=FALSE` to always return sequences as lists. str(parse_yaml(\"foo: [1, 2, 3, null]\", simplify = FALSE)) #> List of 1 #>  $ foo:List of 4 #>   ..$ : int 1 #>   ..$ : int 2 #>   ..$ : int 3 #>   ..$ : NULL  # Parse multiple documents when requested. stream <- \" --- first: 1 --- second: 2 \" str(parse_yaml(stream, multi = TRUE)) #> List of 2 #>  $ :List of 1 #>   ..$ first: int 1 #>  $ :List of 1 #>   ..$ second: int 2  # Read from a file; keep sequences as lists. path <- tempfile(fileext = \".yaml\") writeLines(\"alpha: [true, null]\\nbeta: 3.5\", path) str(read_yaml(path, simplify = FALSE)) #> List of 2 #>  $ alpha:List of 2 #>   ..$ : logi TRUE #>   ..$ : NULL #>  $ beta : num 3.5"},{"path":"https://posit-dev.github.io/r-yaml12/news/index.html","id":"yaml12-development-version","dir":"Changelog","previous_headings":"","what":"yaml12 (development version)","title":"yaml12 (development version)","text":"Initial CRAN submission.","code":""}]
